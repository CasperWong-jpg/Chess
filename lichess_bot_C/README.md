# Parallel Chess Engine
CMU 15618 Project | Casper Wong, Daniela Munoz

## Summary
We are going to parallelize a C chess engine using OpenMP to find the best move for any given board position as fast as possible. We will also analyze the performance and tradeoffs to be made in different parallel implementations.

## Background
It is estimated there are between 10^111 and 10^123 chess board positions, including illegal moves. Without illegal moves, this number drops to 10^40. This is still quite a large number, so it is not possible for a chess engine to analyze all possible positions. For example, Stockfish 8, one of the most advanced chess engines, is only able to think up to 22 moves ahead in 1 second, and it takes exponentially longer to think another move ahead. Given that a typical chess game is 10 or 30 minutes, we cannot afford to spend more than seconds to think about each move.

Typically, chess engines are implemented using Minimax, a tree algorithm where new board positions are generated by making different moves. We can generate positions up to a certain depth of moves and use different heuristics to give each move an estimated score to then choose the best one. 

Generating all possible moves and determining which is the best one takes a long time sequentially. So, there is a lot of potential for parallelism as the simulations for each move are independent of each other. 

## The Challenge
Alpha-beta pruning is commonly used to make Minimax significantly faster, where large portions of the game tree can be avoided if a better move has already been found. 

We plan on using alpha-beta pruning to optimize this algorithm, however this introduces a lot of workload imbalance. Each time a branch is cut and the algorithm decides to no longer consider any of its descendents, that process will idle while waiting for the other threads to complete creating their game tree. So, we need to find a way to balance and share workloads such that threads do not idle unnecessarily. 

Another challenge we see ourselves facing is the communication between threads. Each turn, the Chess engine is considering over a million possible moves (thinking 5 moves ahead). We need to ensure that we do not perform redundant computations between threads, and that each thread is able to communicate with one another about the best move they can achieve. 

## Resources
One of the group partners has previously built a chess engine in Python and is attempting to port it to C. If we are unable to do so while staying on schedule, we plan on using an existing chess engine built in C, such as TSCP or Ethereal. 

We will be using this [Master’s paper](https://www.duo.uio.no/bitstream/handle/10852/53769/master.pdf) as a reference and benchmark for our own program. 

We also plan on using the Lichess API to create the live demo and get ELO rankings for our versions. 

## Goals and Deliverables
### Plan to Achieve
In the research paper that we studied, Østensen was been able to achieve about a 2x speedup with 4 processors, so we also plan to achieve at least a 2x speedup with up to 8 processors. We hope that this enables our Chess Engine to think one further move ahead without a significant time increase.

We also plan on profiling and generating graphs with useful information about the tradeoffs between the number of processors, implementation method (ie. scheduling type), and speedup. 

### Hope to Achieve
We hope to achieve a 2x speedup or greater on 4 processors to be on par with others’ work. We also hope to increase the ELO by 100-200 from the sequential to the parallel version.

### Showcase
We plan on developing a live demo by hooking it up to the Lichess bot API for people to play against! This can also be used to evaluate the final ELO of the chess engine. 

## Platform Choice
We will be using C as our programming language since many of the leading Chess engines are created in this language. We plan on using OpenMP because it allows us to split up work among cores easily using the fork-join model. 

Finally, we will be running this program on regular laptops, such as Macbook Pro with 8 cores or the GHC computers, since we would like to host the Chess Engine locally. 

## Schedule
| Week 1 11/12 - 11/18 | Submit the proposal and research topic                                                                       |
|----------------------|--------------------------------------------------------------------------------------------------------------|
| Week 2 11/19 - 11/25 | Build sequential implementation Perform timing and performance profiling                                     |
| Week 3 11/26 - 12/2  | Develop a naive parallel implementation, Complete and submit milestone report                                |
| Week 4 12/3 - 12/9   | Optimize parallel implementations – explore various OpenMP methods  Perform timing and performance profiling |
| Week 5 12/10 - 12/14 | Complete final parallel implementation, Complete and submit the final report                                 |

## How to run
To run Lichess API:

Change `lichess_bot/config.yml` OAuth token to bot account you own\
`make lichess` \
`cd lichess_bot` \
`python3 lichess-bot.py`